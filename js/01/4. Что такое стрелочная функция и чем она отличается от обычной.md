# Кратко
Стрелочная функция короче по синтаксису и не имеет собственного `this` (берёт его из внешнего контекста). Также её нельзя использовать как конструктор и у неё нет `arguments`.

---

# Стрелочная функция в JavaScript

**Стрелочная функция (arrow function)** — это сокращённый синтаксис объявления функций, появившийся в ES6.  
Записывается с помощью оператора `=>`.

Пример:

```js
// Обычная функция
function sum(a, b) {
  return a + b;
}

// Стрелочная функция
const sumArrow = (a, b) => a + b;
```

---

## Отличия стрелочной функции от обычной

### 1. Синтаксис

- Короче и лаконичнее.
    
- Если тело функции состоит из одного выражения, `return` пишется неявно.
    

```js
const square = x => x * x; // не нужно писать return
```

---

### 2. `this`

- **Обычная функция**: значение `this` зависит от того, **как функция вызвана**.
    
- **Стрелочная функция**: не имеет своего `this`. Она берет `this` из окружающего контекста (лексически).
    

```js
const obj = {
  value: 42,
  regular: function () {
    console.log(this.value);
  },
  arrow: () => {
    console.log(this.value);
  }
};

obj.regular(); // 42  (this = obj)
obj.arrow();   // undefined (this берется из внешнего scope, а там нет value)
```

---

### 3. `arguments`

- **Обычная функция** имеет встроенный объект `arguments`.
    
- **Стрелочная функция** его не имеет. Если нужен — используем rest-параметры `(...args)`.
    

```js
function regular(a, b) {
  console.log(arguments); // [Arguments] { '0': 1, '1': 2 }
}

const arrow = (a, b) => {
  console.log(arguments); // ReferenceError
};

regular(1, 2);
arrow(1, 2);
```

---

### 4. Конструктор

- **Обычная функция** может быть конструктором (через `new`).
    
- **Стрелочная функция** не имеет `[[Construct]]`, поэтому `new` вызовет ошибку.
    

```js
function Person(name) {
  this.name = name;
}
const p = new Person("Oleg"); // ✅ работает

const PersonArrow = (name) => {
  this.name = name;
};
const p2 = new PersonArrow("Oleg"); // ❌ TypeError
```

---

## Сводная таблица

|Отличие|Обычная функция|Стрелочная функция|
|---|---|---|
|Синтаксис|Более длинный|Короткий|
|`this`|Динамический|Лексический|
|`arguments`|Есть|Нет|
|`new`|Можно вызвать|Нельзя вызвать|

---

✅ **Итого**:  
Стрелочные функции делают код короче и удобнее в колбэках, но у них нет собственного `this`, `arguments` и они не подходят как конструкторы.

---

Хочешь, я напишу ещё пример из **реальной практики** (например, использование стрелочной функции внутри `setTimeout` или в методах массивов), чтобы показать, где именно стрелки удобнее всего?